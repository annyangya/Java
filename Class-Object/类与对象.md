面向对象语言的特点：封装性，继承，多态

### 类
#### 成员变量
1. 成员变量的类型：包括基本类型：整型，浮点型，字符型，逻辑类型和引用类型：数组，对象，接口
2. 成员变量的有效范围：成员变量在整个类内都有效，有效性与在类体中的书写位置无关，即使书写在最后在整个类里都有效
#### 方法
1. 方法包括方法头和方法体，在方法体中声明的变量和参数被称为局部变量。
2. 局部变量只在方法内有效，有效性与方法声明的位置有关，方法内的局部变量从它声明的位置之后开始有效。如果局部变量声明在一个复合语句中，那么该局部变量的有效范围是该复合语句，如果声明在一个循环语句中，那么局部变量的有效范围是该循环语句。
3. 区分成员变量和局部变量：如果局部变量和成员变量名字相同，那么该成员变量被隐藏，成员变量在这个方法内暂时失效；
如果想使用被隐藏的成员变量，就要使用关键字this，如y=x+this.x，第一个x为局部变量，第二个为成员变量；
成员变量有默认值，局部变量没有默认值，因此在使用局部变量前，要为其设置一个值
4. 成员变量时可以赋初值，如 int a=12;但是不能出现下列情况
```java
    int a;
    a=12;//赋值语句，只能出现在方法体中
```
#### 构造方法
1. 构造方法的名字与类的名字相同，没有类型。
2. 如果没有编写构造方法，系统会默认为这个类创建一个无参的构造方法，方法体内也没有语句
3. 如果类里定义了一个或多个构造方法，系统就不会提供默认的无参构造方法，所以一般在定义时定义无参和带参的构造方法。
#### 创建对象
这里我们以类A为例，声明一个a实体，假设A类没有静态方法和属性
1. 声明对象的内存模型：A a；声明对象变量a后，a的内存中没有数据，这时称a为一个空对象，空对象不能使用，因为他还没有得到任何“实体”，必须再进行为对象分配变量的操作，即为对象分配实体。
2. new A();     这时会进行两个操作：一，为各个变量分配内存，即为A的成员变量分配内存空间，然后执行构造方法中的语句。如果成员变量在声明时没有指定初始值，使用的构造方法也没有对成员变量进行初始化操作，那么，对于整型的成员变量，默认初值时0，浮点型为0.0，boolean默认初值时false，引用类型初始值为null。
第二，new运算符在为成员变量分配内存之后，会计算出一个称作引用的值（内存信息），即表达式new A()是一个值，A a=new A()即是将引用赋给a，那么给成员变量分配的内存空间将由a管理，成员变量是属于对象a的实体，这些变量属于a。
3. 综上，所谓创建对象就是为对象分配变量，并获得一个引用，以确保这些变量由该对象来操作管理。
4. 创建多个对象时，这些对象的变量分配不同的内存空间。即创建a时给类A中的成员变量分配内存空间，并返回引用给a；当再次创建对象b时，给成员变量分配内存空间，并返回一个引用给b。注意a和b的内存空间是不一样的。
5. 总结：new运算符只能和类的构造方法进行运算，结果返回一个十六进制的数，这个数即被称作对象的引用，即new A()的值是一个引用。在计算出这个引用之前，先给类A的成员变量分配内存空间，然后执行类的构造方法（空对象，还不能被称作完整的对象），当计算出引用之后，就产生了对象，当把引用赋给对象时，对象就拥有了运算符new分配的内存的成员变量。即new运算符为该对象分配了变量。
6. 对象的引用存放在栈内存中，对象的实体（分配的变量）存放在堆内存中。
#### 使用对象
使用运算符 . 可以实现对自己变量的访问和方法的调用：
1. 对象操作自己的变量：对象的属性， 对象.属性
2. 对象操作自己的方法：对象的行为， 对象.方法

#### 对象的引用和实体
1. 避免使用空对象，没有实体的对象称作空对象，空对象不能使用，否则会报错，发生NullPointerException异常
2. 一个类的两个对象有相同的引用，二者就有完全相同的变量。类创建的两个对象有不同的引用，但是如果进行赋值操作如 a=b;那么a和b就有相同的实体（变量）。
3. 垃圾收集：当发现堆内存中的分配的实体不再被栈内存中任何对象使用时，就会释放该实体在堆中占用的内存。如果希望立即进行垃圾回收操作，可让System类调用gc()方法，System.gc();

#### 参数传值
参数属于局部变量，当对象调用方法时，参数被分配内存空间，并要求调用者向参数传值，即方法被调用时，参数变量要有具体的值。
1. 基本数据类型参数的传值：像该参数传递的值的级别不可以高于该参数的级别，如不能像int类型传递float型，但可以向double传递float类型。
2. 引用类型参数的传值：引用数据类型包括数组，对象和接口。传值传递的是变量中存放的引用，而不是变量所引用的实体。如果两个对象有相同的引用，就有相同的实体，如果改变参数变量所引用的实体，就会导致原变量的实体发生同样的变化。如果改变引用则不会影响传值的引用。
3. 可变参数：若干个参数类型相同，可用 … 表示若干个参数，最后一参数是方法参数列表中方的最后一个参数。
```java
public void fun(int...x)
```
fun的参数列表中，从第一个到最后一个x都是int类型，但是出现的int类型的值的个数不确定，称x是参数列表的可变参数的参数代表。
```java
public void fun(double x,int...y)
```
参数列表第一个为double类型，第二个直到最后一个y都是int类型
```java
public void fun(int...x,int...y)
```
上面的示例就是错误的，x代表参数列表的最后一个参数，但是在这个方法中，x不是fun方法的最后一个参数，最后一个参数y不是可变参数x所代表的参数之一
4. 增强型for循环：
```java
public static int fun(int...x){
        int sum=0;
        for(int i=0;i<x.length;i++){
            sum+=x[i];
        }
        return sum;
    }
//增强型for循环
    public static int fun2(int...x){
        int sum=0;
        for(int params:x){//对于循环变量，依次取参数代表所代表的每一个参数值。
         sum+=params;
        }
        return sum;
    }
```
#### 实例变量和类变量的区别（static修饰为类变量）
1. 不同对象的实例变量互不相同：分配给不同对象的实例变量占有不同的内存空间，改变其中一个对象的实例不会影响其他对象的实例变量
2. 所有对象共享类变量：当new运算符创建多个对象时，分配给这些类变量有相同的一块内存，改变其中一个类变量会影响其它对象这个类变量，即对象共享类变量
3. 通过类名直接访问类变量：类变量在类加载到内存时就分配了相应的内存空间，而实例变量只有在创建对象之后才会分配内存，不同的对象分配不同的内存空间。所有对象的类变量都有相同的一块内存，类变量的内存空间知道程序退出运行才释放所有内存。
4. 类变量可以通过对象访问，也可以通过类名访问。实例变量只能通过对象访问，不能通过类名访问。

#### 实例方法和类方法的区别
